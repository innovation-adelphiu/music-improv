<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Music Improvisation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    :root {
      --accent: #4a90e2;
      --accent-soft: #e6f0fb;
      --bg: #f5f5f7;
      --card-bg: #ffffff;
      --text-main: #222;
      --text-muted: #666;
      --danger: #e84545;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .app {
      background: var(--card-bg);
      padding: 20px 24px 24px;
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      max-width: 420px;
      width: 100%;
      margin: 16px;
    }

    .title {
      font-size: 2.0rem;
      font-weight: 800;
      margin-bottom: 16px;
      text-align: center;
    }

    .subtitle {
      font-size: 1.0rem;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 16px;
    }

    .top-controls {
      display: flex;
      justify-content: center;
      gap: 18px;
      margin-bottom: 12px;
    }

    .round-button {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: none;
      background: var(--accent-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.1s;
    }

    .round-button img {
      width: 32px;
      height: 32px;
      pointer-events: none;
    }

    .round-button:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .top-controls .round-button {
      position: relative;
    }

    .round-button.recording {
      background: #ffe7ea;
      box-shadow: 0 0 0 2px rgba(232,69,69,0.5);
    }

    .round-button.recording::after {
      content: '';
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 999px;
      border: 2px solid rgba(232,69,69,0.5);
      opacity: 0.0;
      animation: pulse 1.4s ease-out infinite;
      pointer-events: none;
    }

    @keyframes pulse {
      0%   { transform: scale(0.9); opacity: 0.7; }
      100% { transform: scale(1.2); opacity: 0; }
    }

    /* Progress bar */
    .progress-container {
      position: relative;
      height: 6px;
      border-radius: 999px;
      background: #e3e7f0;
      overflow: hidden;
      margin: 0 6px 12px;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), #7bb3ff);
    }

    /* Piano canvas */
    .piano-wrapper {
      margin-bottom: 12px;
    }

    #pianoCanvas {
      display: block;
      margin: 0 auto;
      border-radius: 6px;
      border: 2px solid #000000;
      background: #ffffff;
      max-width: 100%;
    }

    .note-buttons {
      display: flex;
      flex-wrap: wrap; /* allow wrapping instead of scrollbars */
      gap: 8px;
      justify-content: center;
      margin-bottom: 16px;
    }

    .note-button {
      flex: 1 0 0;   /* equal-sized buttons */
      min-width: 0;
      padding: 10px 0;
      border-radius: 999px;
      border: 1px solid #d0d7e2;
      background: #f9fafc;
      font-size: 1.0rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.08s ease, box-shadow 0.08s ease,
                  transform 0.08s ease, border-color 0.08s;
    }

    .note-button:active,
    .note-button.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      transform: translateY(1px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
    }

    .recording-controls {
      margin-top: 8px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .hidden {
      display: none !important;
    }

    .secondary-button {
      flex: 1 1 auto;
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent-soft);
      color: var(--text-main);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease;
      box-shadow: 0 3px 8px rgba(0,0,0,0.06);
      max-width: 160px;
    }

    .secondary-button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    }

    .secondary-button.primary {
      background: var(--accent);
      color: #fff;
    }

    .status {
      margin-top: 10px;
      font-size: 0.8rem;
      text-align: center;
      color: var(--text-muted);
      min-height: 1.2em;
    }

    @media (max-width: 480px) {
      .app {
        padding: 18px 18px 20px;
      }

      .title {
        font-size: 1.2rem;
      }

      .top-controls {
        gap: 14px;
      }

      .round-button {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="title">Music Improvisation</div>
    <div class="subtitle">Play notes over a background track <br> 
        using the note letter buttons below <br>
        or the keyboard keys 1 through 6. <br>
        You can also record and download <br>
        your musical composition!<br><br>
    </div>

    <div class="top-controls">
      <button id="playToggle" class="round-button" aria-label="Play backing track">
        <img id="playToggleIcon" src="images/play.png" alt="Play">
      </button>
      <button id="recordButton" class="round-button" aria-label="Record improvisation">
        <img src="images/record.png" alt="Record">
      </button>
    </div>

    <!-- Progress bar -->
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>

    <!-- Piano canvas -->
    <div class="piano-wrapper">
      <canvas id="pianoCanvas"></canvas>
    </div>

    <div class="note-buttons">
      <button class="note-button" data-note="C4">C</button>
      <button class="note-button" data-note="D4">D</button>
      <button class="note-button" data-note="E4">E</button>
      <button class="note-button" data-note="G4">G</button>
      <button class="note-button" data-note="A4">A</button>
      <button class="note-button" data-note="C5">C</button>
    </div>

    <div id="recordingControls" class="recording-controls hidden">
      <button id="playRecording" class="secondary-button primary">Play Recording</button>
      <button id="downloadRecording" class="secondary-button">Download</button>
    </div>

    <div id="status" class="status"></div>
  </div>

  <script>
    (function () {
      const AudioContext = window.AudioContext || window.webkitAudioContext;

      let audioCtx = null;
      let masterGain = null;
      let recordDestination = null;
      let mediaRecorder = null;
      let recordingChunks = [];
      let recordingBlob = null;
      let recordingUrl = null;

      const audioBuffers = {}; // cache: url -> AudioBuffer

      let playBackgroundSource = null;    // accompaniment for play button
      let recordBackgroundSource = null;  // accompaniment during recording

      const noteActiveMap = new Map(); // button -> {source, gainNode}

      const playToggleBtn = document.getElementById('playToggle');
      const playToggleIcon = document.getElementById('playToggleIcon');
      const recordButton = document.getElementById('recordButton');

      const recordingControls = document.getElementById('recordingControls');
      const playRecordingBtn = document.getElementById('playRecording');
      const downloadRecordingBtn = document.getElementById('downloadRecording');
      const statusEl = document.getElementById('status');
      const progressBar = document.getElementById('progressBar');

      const noteButtons = Array.from(document.querySelectorAll('.note-button'));
      const noteNameToButton = {};
      noteButtons.forEach(btn => {
        noteNameToButton[btn.dataset.note] = btn;
      });

      // ---------- Piano canvas setup (single octave C4–C5, with half black key over C5) ----------

      const pianoCanvas = document.getElementById('pianoCanvas');
      const pianoCtx = pianoCanvas.getContext('2d');

      const PIANO_WIDTH = 360;
      const startX = 10;
      const startY = 10;
      const whiteKeyCount = 8; // C4 D4 E4 F4 G4 A4 B4 C5
      const whiteKeyGap = 4;

      const totalGap = whiteKeyGap * (whiteKeyCount - 1);
      const whiteKeyWidth = (PIANO_WIDTH - 2 * startX - totalGap) / whiteKeyCount;
      const whiteKeyHeight = 4.0 * whiteKeyWidth;

      const blackKeyWidth = 0.7 * whiteKeyWidth;
      const blackKeyHeight = 0.6 * whiteKeyHeight;

      // height large enough to show full white keys
      const PIANO_HEIGHT = startY + whiteKeyHeight + 10;

      pianoCanvas.width = PIANO_WIDTH;
      pianoCanvas.height = PIANO_HEIGHT;

      const whiteKeyFillColor   = "#EEEEEE";
      const whiteKeyActiveColor = "#88CCFF";
      const whiteKeyBorderColor = "#000000";
      const blackKeyFillColor   = "#444444";
      const blackKeyActiveColor = "#AA88FF";
      const blackKeyBorderColor = "#000000";

      pianoCtx.lineWidth = 2;

      const whiteKeyNames = ["C4","D4","E4","F4","G4","A4","B4","C5"];
      // between: C-D, D-E, E-F, F-G, G-A, A-B, B-C
      // add "C#5" in last slot so we see a half key over the high C
      const blackKeySlots = ["C#4","D#4",null,"F#4","G#4","A#4",null,"C#5"];

      const whiteKeys = [];
      const blackKeys = [];
      let pianoKeyDown = {};

      // build white key rects
      for (let i = 0; i < whiteKeyCount; i++) {
        const x = startX + i * (whiteKeyWidth + whiteKeyGap);
        const y = startY;
        const name = whiteKeyNames[i];
        whiteKeys.push({ name, x, y, w: whiteKeyWidth, h: whiteKeyHeight, isBlack: false });
      }

      // build black key rects
      for (let i = 0; i < blackKeySlots.length; i++) {
        const bName = blackKeySlots[i];
        if (!bName) continue;

        let x;
        const y = startY;

        const x1 = startX + i * (whiteKeyWidth + whiteKeyGap);
        const x2 = startX + (i + 1) * (whiteKeyWidth + whiteKeyGap) + whiteKeyWidth;
        const xMid = (x1 + x2) / 2;
        x = xMid - blackKeyWidth / 2;

        if (bName === "C#5") {
            // Special case: half key on the top-right of high C, cut by the right edge.
            blackKeys.push({ name: bName, x, y, w: blackKeyWidth/2, h: blackKeyHeight, isBlack: true });
        } else {
            blackKeys.push({ name: bName, x, y, w: blackKeyWidth, h: blackKeyHeight, isBlack: true });
        }

      }

      function initPianoKeyDown() {
        pianoKeyDown = {};
        whiteKeys.forEach(k => { pianoKeyDown[k.name] = false; });
        blackKeys.forEach(k => { pianoKeyDown[k.name] = false; });
      }
      initPianoKeyDown();

      function drawPiano() {
        pianoCtx.clearRect(0, 0, PIANO_WIDTH, PIANO_HEIGHT);

        // draw white keys
        for (const key of whiteKeys) {
          pianoCtx.strokeStyle = whiteKeyBorderColor;
          pianoCtx.strokeRect(key.x, key.y, key.w, key.h);
          const active = pianoKeyDown[key.name];
          pianoCtx.fillStyle = active ? whiteKeyActiveColor : whiteKeyFillColor;
          pianoCtx.fillRect(key.x, key.y, key.w, key.h);
        }

        // draw black keys on top (C#5 is partially clipped at the right edge)
        for (const key of blackKeys) {
          pianoCtx.strokeStyle = blackKeyBorderColor;
          pianoCtx.strokeRect(key.x, key.y, key.w, key.h);
          const active = pianoKeyDown[key.name];
          pianoCtx.fillStyle = active ? blackKeyActiveColor : blackKeyFillColor;
          pianoCtx.fillRect(key.x, key.y, key.w, key.h);
        }
      }

      drawPiano();

      // ---------- Status ----------

      function setStatus(text) {
        statusEl.textContent = text || '';
      }

      // ---------- Audio context helpers ----------

      function ensureAudioContext() {
        if (!AudioContext) {
          alert('Web Audio API is not supported in this browser.');
          return false;
        }

        if (!audioCtx) {
          audioCtx = new AudioContext();
          masterGain = audioCtx.createGain();
          masterGain.gain.value = 1.0;
          masterGain.connect(audioCtx.destination);

          // create recording destination and connect master to it
          recordDestination = audioCtx.createMediaStreamDestination();
          masterGain.connect(recordDestination);

          if (window.MediaRecorder) {
            mediaRecorder = new MediaRecorder(recordDestination.stream);
            mediaRecorder.ondataavailable = (e) => {
              if (e.data && e.data.size > 0) {
                recordingChunks.push(e.data);
              }
            };
            mediaRecorder.onstop = handleRecordingStop;
          } else {
            alert('Recording is not supported in this browser.');
          }
        }

        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }

        return true;
      }

      async function getAudioBuffer(url) {
        if (!audioCtx) return null;
        if (audioBuffers[url]) {
          return audioBuffers[url];
        }
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        audioBuffers[url] = audioBuffer;
        return audioBuffer;
      }

      // ---------- Progress bar helpers ----------

      let isBackgroundPlaying = false;
      let isRecordingActive = false;
      let isPlaybackPlaying = false;

      let progressDuration = 0;
      let progressStartTime = 0;
      let progressAnimationFrame = null;

      let recordingAudio = null; // HTMLAudioElement for playback

      function anyMainAudioActive() {
        return isBackgroundPlaying || isRecordingActive || isPlaybackPlaying;
      }

      function startProgress(duration) {
        if (!duration || duration <= 0) {
          stopProgressBar();
          return;
        }
        progressDuration = duration;
        progressStartTime = performance.now();
        if (progressAnimationFrame) {
          cancelAnimationFrame(progressAnimationFrame);
        }
        progressAnimationFrame = requestAnimationFrame(updateProgress);
      }

      function updateProgress() {
        if (!anyMainAudioActive()) {
          stopProgressBar();
          return;
        }

        const now = performance.now();
        const elapsed = (now - progressStartTime) / 1000;
        const ratio = Math.min(elapsed / progressDuration, 1);
        progressBar.style.width = (ratio * 100) + '%';

        if (ratio >= 1) {
          progressAnimationFrame = null;
          return;
        }

        progressAnimationFrame = requestAnimationFrame(updateProgress);
      }

      function stopProgressBar() {
        if (progressAnimationFrame) {
          cancelAnimationFrame(progressAnimationFrame);
          progressAnimationFrame = null;
        }
        progressBar.style.width = '0%';
      }

      // ---------- Backing track (play button) ----------

      function endBackgroundPlayback() {
        playBackgroundSource = null;
        isBackgroundPlaying = false;
        playToggleIcon.src = 'images/play.png';
        setStatus('');
        if (!anyMainAudioActive()) {
          stopProgressBar();
        }
      }

      function isRecordingAudioPlaying() {
        return recordingAudio && !recordingAudio.paused && !recordingAudio.ended;
      }

      function stopRecordingPlayback() {
        if (!recordingAudio) return;
        recordingAudio.pause();
        recordingAudio.currentTime = 0;
        isPlaybackPlaying = false;
        updatePlayRecordingLabel(false);
        if (!anyMainAudioActive()) {
          stopProgressBar();
        }
      }

      function stopRecordingEarly() {
        if (recordBackgroundSource) {
          recordBackgroundSource.onended = null;
          try {
            recordBackgroundSource.stop();
          } catch (e) {}
          recordBackgroundSource = null;
        }
        isRecordingActive = false;

        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }

        playToggleIcon.src = 'images/play.png';
        if (!anyMainAudioActive()) {
          stopProgressBar();
        }
      }

      function handleRecordBackgroundEnded() {
        isRecordingActive = false;
        recordBackgroundSource = null;
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
        playToggleIcon.src = 'images/play.png';
        if (!anyMainAudioActive()) {
          stopProgressBar();
        }
      }

      async function toggleBackgroundPlayback() {
        if (!ensureAudioContext()) return;

        // If recording playback is active, stop it first
        if (isRecordingAudioPlaying()) {
          stopRecordingPlayback();
        }

        // If currently recording, this acts as "stop recording early"
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          stopRecordingEarly();
          return;
        }

        // Normal play/stop of accompaniment
        if (playBackgroundSource) {
          try {
            playBackgroundSource.onended = null;
            playBackgroundSource.stop();
          } catch (e) {}
          endBackgroundPlayback();
          return;
        }

        const buffer = await getAudioBuffer('accompaniment.mp3');
        if (!buffer) return;

        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(masterGain);
        src.onended = endBackgroundPlayback;
        playBackgroundSource = src;

        playToggleIcon.src = 'images/stop.png';
        setStatus('Playing backing track...');
        isBackgroundPlaying = true;
        startProgress(buffer.duration);
        src.start();
      }

      // ---------- Notes (C, D, E, G, A, high C) ----------

      async function startNote(button) {
        if (!ensureAudioContext()) return;

        const note = button.dataset.note;
        if (!note) return;

        const fileName = 'audio/' + note + '.wav';
        const buffer = await getAudioBuffer(fileName);
        if (!buffer) return;

        if (noteActiveMap.has(button)) {
          stopNote(button);
        }

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;

        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 1.0;

        source.connect(gainNode);
        gainNode.connect(masterGain);

        noteActiveMap.set(button, { source, gainNode });
        button.classList.add('active');

        // Highlight matching piano key, if it exists
        if (note in pianoKeyDown) {
          pianoKeyDown[note] = true;
          drawPiano();
        }

        source.start();
      }

      function stopNote(button) {
        if (!audioCtx) return;
        const data = noteActiveMap.get(button);
        const note = button.dataset.note;

        if (!data) {
          button.classList.remove('active');
          if (note in pianoKeyDown) {
            pianoKeyDown[note] = false;
            drawPiano();
          }
          return;
        }

        const { source, gainNode } = data;
        noteActiveMap.delete(button);
        button.classList.remove('active');

        if (note in pianoKeyDown) {
          pianoKeyDown[note] = false;
          drawPiano();
        }

        const now = audioCtx.currentTime;
        try {
          gainNode.gain.cancelScheduledValues(now);
          gainNode.gain.setValueAtTime(gainNode.gain.value, now);
          gainNode.gain.linearRampToValueAtTime(0.0, now + 0.5);
          source.stop(now + 0.52);
        } catch (e) {
          // ignore if already stopped
        }
      }

      function attachNoteHandlers(button) {
        button.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          startNote(button);
        });

        button.addEventListener('pointerup', () => {
          stopNote(button);
        });

        button.addEventListener('pointerleave', () => {
          stopNote(button);
        });

        button.addEventListener('pointercancel', () => {
          stopNote(button);
        });
      }

      // ---------- Recording session ----------

      async function startRecordingSession() {
        if (!ensureAudioContext()) return;
        if (!mediaRecorder) {
          setStatus('Recording is not available in this browser.');
          return;
        }

        // If recording playback is active, stop it first
        if (isRecordingAudioPlaying()) {
          stopRecordingPlayback();
        }

        // If accompaniment is playing via play button, stop it
        if (playBackgroundSource) {
          try {
            playBackgroundSource.onended = null;
            playBackgroundSource.stop();
          } catch (e) {}
          endBackgroundPlayback();
        }

        if (mediaRecorder.state === 'recording') {
          return;
        }

        // Clear previous recording
        recordingChunks = [];
        recordingBlob = null;
        if (recordingUrl) {
          URL.revokeObjectURL(recordingUrl);
          recordingUrl = null;
        }
        recordingControls.classList.add('hidden');
        setStatus('Recording improv...');

        recordButton.classList.add('recording');

        mediaRecorder.start();

        const buffer = await getAudioBuffer('accompaniment.mp3');
        if (!buffer) {
          setStatus('Could not load background track.');
          try {
            if (mediaRecorder.state === 'recording') {
              mediaRecorder.stop();
            }
          } catch (e) {}
          recordButton.classList.remove('recording');
          return;
        }

        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(masterGain);
        src.onended = handleRecordBackgroundEnded;
        recordBackgroundSource = src;
        isRecordingActive = true;

        // While recording, play button looks like "stop"
        playToggleIcon.src = 'images/stop.png';

        startProgress(buffer.duration);
        src.start();
      }

      function handleRecordingStop() {
        recordButton.classList.remove('recording');
        if (!recordingChunks.length) {
          setStatus('No audio captured.');
          return;
        }
        recordingBlob = new Blob(recordingChunks, { type: 'audio/webm' });
        recordingUrl = URL.createObjectURL(recordingBlob);
        recordingControls.classList.remove('hidden');
        updatePlayRecordingLabel(false);
        setStatus('Recording ready. You can listen or download.');
      }

      // ---------- Recording playback (toggle play/stop) ----------

      function updatePlayRecordingLabel(isPlaying) {
        playRecordingBtn.textContent = isPlaying ? 'Stop Recording' : 'Play Recording';
      }

      function playRecordingToggle() {
        if (!recordingBlob || !recordingUrl) {
          setStatus('No recording available yet.');
          return;
        }

        // If accompaniment is playing, stop it
        if (playBackgroundSource) {
          try {
            playBackgroundSource.onended = null;
            playBackgroundSource.stop();
          } catch (e) {}
          endBackgroundPlayback();
        }

        // If currently playing, stop
        if (isRecordingAudioPlaying()) {
          stopRecordingPlayback();
          return;
        }

        // Start playback
        recordingAudio = new Audio(recordingUrl);
        isPlaybackPlaying = true;
        updatePlayRecordingLabel(true);

        recordingAudio.addEventListener('loadedmetadata', () => {
          if (isPlaybackPlaying && recordingAudio.duration && !isNaN(recordingAudio.duration)) {
            startProgress(recordingAudio.duration);
          }
        });

        recordingAudio.onended = () => {
          isPlaybackPlaying = false;
          updatePlayRecordingLabel(false);
          if (!anyMainAudioActive()) {
            stopProgressBar();
          }
        };

        recordingAudio.play().catch(() => {
          isPlaybackPlaying = false;
          updatePlayRecordingLabel(false);
          if (!anyMainAudioActive()) {
            stopProgressBar();
          }
        });
      }

      function prepareDownload() {
        if (!recordingBlob || !recordingUrl) {
          setStatus('No recording available yet.');
          return;
        }
        const a = document.createElement('a');
        a.href = recordingUrl;
        a.download = 'music-improvisation.webm';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      // ---------- Keyboard shortcuts: 1–6 for notes ----------

      const keyToButton = {
        '1': noteButtons[0],
        '2': noteButtons[1],
        '3': noteButtons[2],
        '4': noteButtons[3],
        '5': noteButtons[4],
        '6': noteButtons[5]
      };

      document.addEventListener('keydown', (e) => {
        const key = e.key;
        const btn = keyToButton[key];
        if (!btn) return;
        if (e.repeat) return;
        e.preventDefault();
        startNote(btn);
      });

      document.addEventListener('keyup', (e) => {
        const key = e.key;
        const btn = keyToButton[key];
        if (!btn) return;
        e.preventDefault();
        stopNote(btn);
      });

      // ---------- Wire up UI ----------

      playToggleBtn.addEventListener('click', toggleBackgroundPlayback);
      recordButton.addEventListener('click', startRecordingSession);
      playRecordingBtn.addEventListener('click', playRecordingToggle);
      downloadRecordingBtn.addEventListener('click', prepareDownload);

      noteButtons.forEach(attachNoteHandlers);
    })();
  </script>
</body>
</html>
